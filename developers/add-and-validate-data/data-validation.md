# Data Validation

Vana uses a [proof-of-contribution](../../core-concepts/key-elements/proof-of-contribution/ "mention")system to validate data submitted to the network. "Valid" means something different in each DLP, because different DLPs value data differently.

Anyone can submit data to the Vana network. However, for data to be considered valid by a DLP, it must be attested for by a trusted party, i.e. [validators.md](../../core-concepts/roles/validators.md "mention") in a DLP. These trusted parties issue an attestation to prove that this data is, in fact, authentic, high-quality, unique, and has whatever other properties DLPs value in its data contributions.&#x20;

Data attestations live offchain, and a URL to a data's attestation is written onchain alongside the data itself.&#x20;

* **`signed_fields`** Contains the main data fields that are signed by the prover.
  * **`subject`** Information about the datapoint being attested for.
    * **`url`** URL where the encrypted file lives.
    * **`owner_address`** Wallet address of the file owner.
    * **`decrypted_file_checksum`** Checksum of the decrypted file for integrity verification.
    * **`encrypted_file_checksum`** Checksum of the encrypted file for integrity verification.
    * **`encryption_seed`** The message that was signed by the owner to retrieve the encryption key.
  * **`prover`** Information about the prover.
    * **`type`** Type of the prover, `satya` is one of the confidential TEE nodes in the Satya network. Proofs can also be `self-signed` where the data owner generates the proof.
    * **`address`** Wallet address of the prover.
    * **`url`** URL or address where the prover service is hosted.
  * **`proof`** Details about the generated proof.
    * **`image_url`** Docker image URL of where the instructions to generate the proof is downloaded from
    * **`created_at`** Timestamp of when the proof was created.
    * **`duration`** Duration of the proof generation process, in seconds.
    * **`dlp_id`** DLP ID from the [Root Network Contract](../smart-contracts.md#root-network-contract), this is used to tie the proof to a DLP.
    * **`valid`** Boolean indicating if the subject is valid.
    * **`score`** Overall score of the subject, from 0-1.
    * **`authenticity`** Authenticity score of the subject, from 0-1.
    * **`ownership`** Ownership score of the subject, from 0-1.
    * **`quality`** Quality score of the subject, from 0-1.
    * **`uniqueness`** Uniqueness score of the subject, from 0-1.
    * **`attributes`** Additional key/value pairs that will be available on the public proof. These can be used to quickly view properties about the encrypted subject.
* **`signature`** Generated by the prover signing a stringified representation of `signed_fields`, sorted by the key name. To verify it, we can take the signature and the striningifed representation, and extract the address that signed it, which should match the `prover.address`.

## Running Proof-of-Contribution in the Satya Network

The recommended way of validating data securely in the Vana Network is by using the Satya Network, a group of highly confidential nodes that run on special hardware. At a high level, the data contributor adds unverified data, and requests a proof-of-contribution job from the [satya-validators.md](../create-a-data-liquidity-pool-dlp/satya-validators.md "mention") (and pay a small fee to have their data validated). Once validated, the Satya validator will write the proof on chain.

## Proof-of-Contribution Template

To run PoC in the Satya Network, a DLP builder must implement a simple proof-of-contribution function using this template.

{% hint style="info" %}
PoC Template: [https://github.com/vana-com/vana-satya-proof-template](https://github.com/vana-com/vana-satya-proof-template)
{% endhint %}

The diagram below explains how this PoC template works.&#x20;

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p>Proof-of-contribution running in a Satya node</p></figcaption></figure>

1. The data contributor adds their encrypted data onchain, via the [Data Registry](../smart-contracts.md#data-registry-contract).
2. They request a validation job, paying a small fee. Once a Satya node is available to run the job, they connect directly to the node, and send them the encryption key and the proof-of-contribution docker image that needs to run on the data to validate it.
3. The Satya node receives the key, and downloads the encrypted file, and decrypts it
4. The Satya node places the decrypted file in a temporary, shielded\* location. The node operator cannot see the contents of this location.
5. The Satya node downloads and initializes a docker container to run the specified proof-of-contribution, and mounts the input and output volumes. The PoC container will have access to the decrypted file.
6. The PoC container runs its validations on the decrypted data, and outputs the attestation. More information on data attestation can be found here: [data-attestation.md](data-attestation.md "mention").
7. The Satya node reads the output, and generates the proof.
8. The Satya node writes the proof onchain, and claims the fee as a reward for completing that work.

{% hint style="info" %}
\* A [Gramine shielded container](https://gramine.readthedocs.io/projects/gsc/en/latest/) is a specialized type of container that leverages the Gramine library OS to run applications in a secure, isolated environment, typically utilizing hardware-based trusted execution environments (TEEs) like Intel SGX.
{% endhint %}

## Satya Network Integration

{% hint style="warning" %}
More information on integrating with the Satya network for data validation is coming soon.
{% endhint %}

